<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单行文字垂直/水平跑马灯效果]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%8D%95%E8%A1%8C%E6%96%87%E5%AD%97%E5%9E%82%E7%9B%B4-%E6%B0%B4%E5%B9%B3%E8%B7%91%E9%A9%AC%E7%81%AF%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[需求描述接到的需求是这样的：跑马灯效果 一次展示一行文字 循环滚动 文字滚动到视野中停留一秒后滚出。静态效果如下图，文字从下往上或者从右往左滚动，滚动到此位置时停留一秒（不会传动图…网络上有比较多的多行文字循环滚动的demo,找了一下好像能满足单行并且可停留一秒的比较少（emmm可能我没认真找下面贴出我的最终解决方案。 解决方案垂直方向滚动使用一个定时器 不断改变最外层div的scrollTop，为了能循环滚动，增加一个与con1一样的con2PS：这里的time选用1000/60是因为想要模拟window.requestAnimationFrame(一般1000ms60帧，当然了，你也可以直接使用requestAnimationFrame代替setInterval，效果更好1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单行文字垂直跑马灯效果&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; ul,li&#123; list-style:none; display:block; margin: 0; padding: 0; &#125; #loop-show-box &#123; width: 300px; height: 25px; line-height: 25px; background: red; position: absolute; top: 0; left: 0; right: 0; overflow: hidden; &#125; .li-style &#123; width: 100%; height: 25px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;loop-show-box&quot;&gt; &lt;ul id=&quot;con1&quot;&gt; &lt;li class=&quot;li-style&quot;&gt;测试1号&lt;/li&gt; &lt;li class=&quot;li-style&quot;&gt;测试2号&lt;/li&gt; &lt;li class=&quot;li-style&quot;&gt;测试3号&lt;/li&gt; &lt;li class=&quot;li-style&quot;&gt;测试4号&lt;/li&gt; &lt;/ul&gt; &lt;ul id=&quot;con2&quot;&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var area = document.getElementById(&apos;loop-show-box&apos;); var con1 = document.getElementById(&apos;con1&apos;); var con2 = document.getElementById(&apos;con2&apos;); var mytimer1 = null; var mytimer = null; var time = 1000 / 60; con2.innerHTML = con1.innerHTML; function scrollUp () &#123; if (area.scrollTop &gt;= con1.offsetHeight) &#123; area.scrollTop = 0; &#125; else &#123; if (area.scrollTop % 25 == 0) &#123; clearInterval(mytimer); clearInterval(mytimer1); mytimer1 = setTimeout(function () &#123; mytimer = setInterval(scrollUp, time); &#125;, 1000); &#125; area.scrollTop++; &#125; &#125; mytimer = setInterval(scrollUp, time);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 水平方向滚动水平方法滚动的具体实现其实跟垂直方向类似的，不同的是要改变的是容器的scrollLeft1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单行文字水平跑马灯效果&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; .container &#123; width: 400px; height: 25px; display: flex; flex-direction: row; justify-content: center; align-items: center; margin: 100px auto; &#125; .icon &#123; width: 15px; margin-right: 15px; &#125; #loop-show-box &#123; width: 300px; height: 25px; line-height: 25px; background: red; overflow: auto; white-space: nowrap; &#125; .li-style &#123; width: 300px; height: 25px; text-align: left; /*使用inline-block的时候两个item之间会存在间距（当然了你可以把它们写在一行以去除这样的间距*/ display: inline-flex; &#125; #con1,#con2 &#123; display: inline-flex; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;img src=&quot;img/horn.png&quot; class=&quot;icon&quot;&gt; &lt;div id=&quot;loop-show-box&quot;&gt; &lt;div id=&quot;con1&quot;&gt; &lt;div class=&quot;li-style&quot;&gt;测试1号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试2号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试3号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试4号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试5号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试6号&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;con2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var area = document.getElementById(&apos;loop-show-box&apos;); var con1 = document.getElementById(&apos;con1&apos;); var con2 = document.getElementById(&apos;con2&apos;); var mytimer1 = null; var mytimer = null; var time = 1000 / 60; con2.innerHTML = con1.innerHTML; function scrollUp () &#123; if (area.scrollLeft &gt;= con1.offsetWidth) &#123; area.scrollLeft = 0; &#125; else &#123; // 可根据想要的速度调节步长 area.scrollLeft += 2; if (area.scrollLeft % 300 == 0) &#123; clearInterval(mytimer); clearInterval(mytimer1); mytimer1 = setTimeout(function () &#123; mytimer = setInterval(scrollUp, time); &#125;, 1000); &#125; &#125; &#125; mytimer1 = setTimeout(function () &#123; mytimer = setInterval(scrollUp, time); &#125;, 1000)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注：此文于2018-06-07发表于技术专栏LetCodeFly，参考链接：单行文字垂直/水平跑马灯效果]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[H5 Video 使用网络地址时获取其大小和第一帧图片]]></title>
    <url>%2F2019%2F03%2F04%2FH5-Video-%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E6%97%B6%E8%8E%B7%E5%8F%96%E5%85%B6%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%AC%AC%E4%B8%80%E5%B8%A7%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[问题描述某一天接了个需求，要求前端获取视频文件的大小、时长以及第一帧图片传给后端服务器存储，这样有两种情况，一种是通过input上传本地视频文件，一种是给出视频的网络地址，将其直接赋值给video标签的src属性。 使用input标签上传本地视频使用&lt;input type=&quot;file&quot;&gt;上传的视频文件，这都好说，有了file文件对象，可以随意操作，获取其size，再通过FileReader对象来处理file。这里附上一个demo(使用vue)123456789101112131415161718192021222324252627&lt;img id=&quot;video-poster&quot; alt=&quot;视频封面&quot; /&gt;&lt;input type=&quot;file&quot; id=&quot;upload-video&quot; accept=&quot;video/*&quot; @change=&quot;uploadVideo&quot; /&gt;&lt;video id=&quot;video&quot; controls /&gt;```json```javascript uploadVideo: function () &#123; var video_file = document.getElementById(&apos;upload-video&apos;).files[0]; // 这里可以打印出视频文件的size大小 console.log(video_file.size); if (!video_file) return; var reader = new FileReader(); reader.onload = function () &#123; var videoDom = document.getElementById(&apos;video&apos;); videoDom.onloadeddata = function () &#123; // 这里可以打印视频时长 console.log(this.duration); // 这里取得视频封面 var canvas = document.createElement(&apos;canvas&apos;); canvas.width = 300; canvas.height = 300 * this.videoHeight / this.videoWidth; canvas.getContext(&apos;2d&apos;).drawImage(this, 0, 0, canvas.width, canvas.height); document.getElementById(&apos;video-poster&apos;).src = canvas.toDataURL(); &#125; videoDom.src = reader.result; &#125; reader.readAsDataURL(video_file); &#125; 使用网络地址访问视频现在需求变一下，视频不是从本地引入的，而是后端服务器直接给前端返回视频src，前端在对视频播放之后需要给后端服务器上传视频的大小，时长，第一帧图片，我内心：？？？？时长倒是好处理，可以借鉴第一种情况，通过监听onloadeddata的方法获取，问题来了，大小怎么获取？？上一面文章里面提供了一种canvas图片跨域的方法https://segmentfault.com/a/1190000014478087，最后一种方法也可以用来解决这里的需求，通过发起一个ajax请求，将网络地址的视频下载为本地blob视频文件，再将blob文件赋值给视频的src12345678910111213141516171819202122232425function getVideoBlob (url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, url, true); xhr.responseType = &apos;blob&apos;; xhr.onload = function () &#123; if (this.status == 200) &#123; // 获取视频文件大小 console.log(this.response.size / 1000000 + &apos;MB&apos;); spiderVideoResponse = this.response; // 将response赋值为Video的src 或者也可以使用preView转换为base64的格式 // 截取第一帧的图片方法跟第一种情况一样，而且还解决了获取图片时跨域的问题 一举两得 video.src = URL.createObjectURL(this.response); &#125; &#125;; xhr.send();&#125;function preView (url) &#123; let reader = new FileReader(); getImageBlob(url, function (blob) &#123; reader.readAsDataURL(blob); &#125;); reader.onload = function (e) &#123; console.log(e.loaded) &#125;&#125; 这里面根据视频的两种情况分别提供了解决方法，可根据自身情况选取，自封为“最全解决方法”hhhh 注：此文于2018-04-20发表于技术专栏LetCodeFly，参考链接：H5 Video 使用网络地址时获取其大小和第一帧图片]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[canvas图片绘制跨域问题解决方案黑科技版]]></title>
    <url>%2F2019%2F03%2F04%2Fcanvas%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%BB%91%E7%A7%91%E6%8A%80%E7%89%88%2F</url>
    <content type="text"><![CDATA[图片跨域问题的一般解决方法注：此文2018-04-19发表于个人技术专栏LetCodeFly指路：canvas图片绘制跨域问题解决方案Tainted canvases may not be exported.当使用canvas绘制网络图片的时候，经常会出现“Tainted canvases may not be exported”报错，上网搜一下解决方案，应该给的都是给img添加crossOrigin属性，尝试了一下，确实可用。看下面的一个例子：html代码：12&lt;canvas id=&quot;canvas&quot; style=&quot;display: none&quot;&gt;&lt;/canvas&gt;&lt;img id=&quot;canvasImg&quot; /&gt; javascript代码：1234567891011var img = new Image();img.setAttribute(&apos;crossOrigin&apos;, &apos;anonymous&apos;);var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&apos;2d&apos;);img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height + 200; ctx.drawImage(img, 0, 0); document.getElementById(&apos;canvasImg&apos;).src = canvas.toDataURL(&quot;image/jpeg&quot;, 1); &#125;img.src = &apos;http://img.hb.aicdn.com/38d8f519b3f464a80d85ed9632fed904ed0181f41d632-ZHrigO_fw658&apos;; 这样就可以正常画出图片了。 微信图片的问题但是我发现这个方法用于绘制微信头像的时候有概率会出现问题，当然了这里面指的是将图片的网络地址直接赋值给图片的src。【之所以说有概率会出现问题是因为我通过上面的方法去完成需求的时候并没有画出头像（微信头像放在wx.qlogo.cn域名下，然而我今天准备写这篇文章的时候突然就可以了，见鬼当时的时候我们找了很多方法，发现，在头像url后面加上时间戳的话就可以了【emmm神操作即：1img.src = &apos;http://wx.qlogo.cn/mmopen/vi_32/RnLIHfXibgFHlticiclzflpriaLsC3TS9b2Sbj05Wh3vGlhcFutt18dfkXGUt8x11e4q2KHlX4EHHaBb6XylLQW1kQ/0?timeStamp=&apos;+new Date(); 其他的解法今天找了个新的方法去解决canvas图片跨域的问题：将文件读入到blob文件对象，然后使用URL.createObjectURL转换成src可用的地址123456789101112131415161718192021222324252627282930313233//直接读成blob文件对象function getImageBlob (url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open('get', url, true); xhr.responseType = 'blob'; xhr.onload = function () &#123; if (this.status == 200) &#123; imgResponse = this.response; //这里面可以直接通过URL的api将其转换，然后赋值给img.src //也可以使用下面的preView方法将其转换成base64之后再赋值 img.src = URL.createObjectURL(this.response); &#125; &#125;; xhr.send(); &#125; //这里面将blob转换成base64 function preView (url) &#123; let reader = new FileReader(); getImageBlob(url, function (blob) &#123; reader.readAsDataURL(blob); &#125;); reader.onload = function (e) &#123; console.log(e.loaded) &#125; &#125; img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height + 200; ctx.drawImage(img, 0, 0); document.getElementById('canvasImg').src = canvas.toDataURL("image/jpeg", 1); &#125; var imgResponse = ''; getImageBlob('http://wx.qlogo.cn/mmopen/vi_32/RnLIHfXibgFHlticiclzflpriaLsC3TS9b2Sbj05Wh3vGlhcFutt18dfkXGUt8x11e4q2KHlX4EHHaBb6XylLQW1kQ/0');]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[测试文章]]></title>
    <url>%2F2019%2F02%2F12%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[hello欢迎来到封闭货车]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
