<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[canvas图片绘制跨域问题解决方案黑科技版]]></title>
    <url>%2F2019%2F03%2F04%2Fcanvas%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%BB%91%E7%A7%91%E6%8A%80%E7%89%88%2F</url>
    <content type="text"><![CDATA[图片跨域问题的一般解决方法注：此文2018-04-19发表于个人技术专栏LetCodeFly指路：canvas图片绘制跨域问题解决方案Tainted canvases may not be exported.当使用canvas绘制网络图片的时候，经常会出现“Tainted canvases may not be exported”报错，上网搜一下解决方案，应该给的都是给img添加crossOrigin属性，尝试了一下，确实可用。看下面的一个例子：html代码：12&lt;canvas id=&quot;canvas&quot; style=&quot;display: none&quot;&gt;&lt;/canvas&gt;&lt;img id=&quot;canvasImg&quot; /&gt; javascript代码：1234567891011var img = new Image();img.setAttribute(&apos;crossOrigin&apos;, &apos;anonymous&apos;);var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&apos;2d&apos;);img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height + 200; ctx.drawImage(img, 0, 0); document.getElementById(&apos;canvasImg&apos;).src = canvas.toDataURL(&quot;image/jpeg&quot;, 1); &#125;img.src = &apos;http://img.hb.aicdn.com/38d8f519b3f464a80d85ed9632fed904ed0181f41d632-ZHrigO_fw658&apos;; 这样就可以正常画出图片了。 微信图片的问题但是我发现这个方法用于绘制微信头像的时候有概率会出现问题，当然了这里面指的是将图片的网络地址直接赋值给图片的src。【之所以说有概率会出现问题是因为我通过上面的方法去完成需求的时候并没有画出头像（微信头像放在wx.qlogo.cn域名下，然而我今天准备写这篇文章的时候突然就可以了，见鬼当时的时候我们找了很多方法，发现，在头像url后面加上时间戳的话就可以了【emmm神操作即：1img.src = &apos;http://wx.qlogo.cn/mmopen/vi_32/RnLIHfXibgFHlticiclzflpriaLsC3TS9b2Sbj05Wh3vGlhcFutt18dfkXGUt8x11e4q2KHlX4EHHaBb6XylLQW1kQ/0?timeStamp=&apos;+new Date(); 其他的解法今天找了个新的方法去解决canvas图片跨域的问题：将文件读入到blob文件对象，然后使用URL.createObjectURL转换成src可用的地址123456789101112131415161718192021222324252627282930313233//直接读成blob文件对象function getImageBlob (url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open('get', url, true); xhr.responseType = 'blob'; xhr.onload = function () &#123; if (this.status == 200) &#123; imgResponse = this.response; //这里面可以直接通过URL的api将其转换，然后赋值给img.src //也可以使用下面的preView方法将其转换成base64之后再赋值 img.src = URL.createObjectURL(this.response); &#125; &#125;; xhr.send(); &#125; //这里面将blob转换成base64 function preView (url) &#123; let reader = new FileReader(); getImageBlob(url, function (blob) &#123; reader.readAsDataURL(blob); &#125;); reader.onload = function (e) &#123; console.log(e.loaded) &#125; &#125; img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height + 200; ctx.drawImage(img, 0, 0); document.getElementById('canvasImg').src = canvas.toDataURL("image/jpeg", 1); &#125; var imgResponse = ''; getImageBlob('http://wx.qlogo.cn/mmopen/vi_32/RnLIHfXibgFHlticiclzflpriaLsC3TS9b2Sbj05Wh3vGlhcFutt18dfkXGUt8x11e4q2KHlX4EHHaBb6XylLQW1kQ/0');]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[测试文章]]></title>
    <url>%2F2019%2F02%2F12%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[hello欢迎来到封闭货车 1封闭货车封闭货车封闭货车封闭货车封闭货车 1封闭货车封闭货车封闭货车封闭货车封闭货车 1封闭货车封闭货车封闭货车封闭货车封闭货车 1封闭货车封闭货车封闭货车封闭货车封闭货车 哈哈哈这是测试文章 这是小标题哇 你知道嘛这是大标题]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
