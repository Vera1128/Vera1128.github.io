<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网站footer沉底效果的三种解决方案]]></title>
    <url>%2F2019%2F05%2F27%2F%E7%BD%91%E7%AB%99footer%E6%B2%89%E5%BA%95%E6%95%88%E6%9E%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[问题背景很多网站设计一般是两个部分，content + footer，content里面装的是网站主体内容，footer里面展示网站的注册信息等等，因为网站内容高度不定的原因，会出现下面两种情况：1.内容较少时，这个footer固定在在页面的底部。如下所示：2.内容较长时，footer跟在内容后面滑动，大致表现如下图红色框起来的部分（对应网址：http://www.sbc-mcc.com/）： 这个需求在PC端还是很常见的，我在自己的应用中也遇到了这个问题，今天总结了一下实现这种布局的几个方法。 方法1 使用js计算为什么第一个就采用js控制的呢，因为实不相瞒，当初我第一次遇到这个问题的时候，直接就使用js去解决的（主要是我知道js肯定能实现的，所以也就没有花时间去想别的方法）主要思路是：在页面加载完成后计算屏幕高度 - content内容真实的高度的值，如果差值大于footer的高度，就给footer的style加上fixed定位，使它固定在屏幕底部。demo代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;footer沉底效果&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; margin: 0, padding: 0; box-sizing: border-box; position: relative; &#125; html, body &#123; width: 100%; height: 100%; &#125; #container &#123; width: 100%; height: 100%; &#125; #content &#123; background: blue; &#125; #footer &#123; width: 100%; height: 100px; background: red; &#125; .footer-fixed &#123; position: fixed; left: 0; bottom: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container"&gt; &lt;div id="content"&gt; content &lt;/div&gt; &lt;div id="footer"&gt; footer &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; let height = document.getElementById('container').clientHeight - document.getElementById('content').clientHeight; // 这里给footer加上另外的class,使其固定 if (height &gt; 100) document.getElementById('footer').classList.add('footer-fixed');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 本着能使用css解决就绝对不使用js的原则，这个方法虽然最容易想到，但是还是不推荐使用，而且，这段css代码要获取clientHeight，将会导致页面页面重排和重绘，性能考虑上来说，也不推荐。 方法2 采用flex布局 + min-heightflex布局中的justify-content: space-between;搭配超级好用的min-height，刚好可以满足在content内容不足的时候，footer的沉底效果demo代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;footer沉底效果&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; margin: 0; padding: 0; box-sizing: border-box; position: relative; &#125; html, body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; #container &#123; width: 100%; // 重点代码 // 虽然不知道container的高度，但是可以设置一个最小高度，这样有利于布局 min-height: 100%; display: flex; flex-direction: column; justify-content: space-between; &#125; #content &#123; background: blue; &#125; #footer &#123; width: 100%; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container"&gt; &lt;div id="content"&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; &lt;/div&gt; &lt;div id="footer"&gt; footer &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; min-height实在是超级好用的一个css属性了，搭配flex轻松实现沉底效果。 方法3 巧用flex + margin-top这个技巧是在讲margin auto的妙用中学到的，在flex格式化上下文中，margin auto会自动去分配剩余空间。这里面我们可以在footer上使用margin-top:auto来达到沉底效果。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;footer沉底效果&lt;/title&gt; &lt;style type="text/css"&gt; div &#123; margin: 0; padding: 0; box-sizing: border-box; position: relative; &#125; html, body &#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; #container &#123; width: 100%; min-height: 100%; display: flex; flex-direction: column; &#125; #content &#123; background: blue; &#125; #footer &#123; width: 100%; height: 100px; background: red; margin-top: auto; // 重点代码 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="container"&gt; &lt;div id="content"&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; content &lt;br&gt; &lt;/div&gt; &lt;div id="footer"&gt; footer &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 总结：以上三种方法都属于没什么副作用的，其实实现这种沉底效果还有别的实现方式，但是对其他布局有影响，这里不赘述，之后有了更好的解决方案，再来更新。PS：之前margin auto没有深入了解过，了解之后发现还是很神奇的，推荐右边文章探秘 flex 上下文中神奇的自动 margin]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手机浏览器自动播放视频video（设置autplay无效）的解决方案]]></title>
    <url>%2F2019%2F03%2F06%2F%E6%89%8B%E6%9C%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91video%EF%BC%88%E8%AE%BE%E7%BD%AEautplay%E6%97%A0%E6%95%88%EF%BC%89%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[1、问题的提出某一天接了个需求，需要在手机的H5页面内加入视频，我开开心心做完，准备交付的时候，问题来了，PM想要用户一进入页面，视频就开始播放，不需要用户手动点击。 2、尝试解决加autoplay“视频自动播放”这个需求是ok的，那我就在video标签上加个autoplay属性嘛，在PC端浏览器里面试了一下，运行流畅，没有遇到什么问题，但是放在手机浏览器里面打开，就跟没设置autoplay是一样的。 监听canplay那不行的话，我在页面加载完成的时候，监听video的canplay，然后执行play()，应该可以运行了吧？然而放到手机里一看，还是不行。12345&lt;video id=&quot;video&quot; src=&quot;video.mp4&quot; controls&gt;&lt;/video&gt;var video = document.querySelector(&apos;#video&apos;);video.addEventListener(&apos;canplay&apos;, function () &#123; video.play();&#125;) 3、思考问题来了，加autoplay不行，可以理解，可能手机浏览器不支持这个属性吧，但是我监听视频加载完成，手动去play()，这是程序常规方法，为什么也不行？我尝试在监听回调里面加了个alert,发现没有弹出框。所以我很长一段时间认为，手机浏览器无法自动播放视频，是因为内存大小的限制，导致无法监听video的加载完成。 4、解决方案方案1 使用弹框昨天在segment上游荡，发现了原来现在的手机浏览器是不允许网页中视频自动播放的，只有与用户进行了一次交互动作，才可以播放视频。（音频同理，这里就不重复提）我尝试了一下，在页面上加一个弹框，用户点击了弹框之后(相当于一次交互完成)，开始播放视频，发现是可以播放的，部分代码如下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, width=device-width&quot;&gt; &lt;title&gt;视频自动播放&lt;/title&gt; &lt;style&gt; html, body &#123; width: 100%; height: 100%; &#125; .video-container &#123; width: 300px; height: 600px; display: flex; flex-direction: column; justify-content: center; align-items: center; overflow: hidden; margin: 0 auto; &#125; #video &#123; display: block; width: 100%; &#125; #mask &#123; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.83); position: absolute; top: 0; left: 0; z-index: 2; display: flex; flex-direction: row; justify-content: center; align-items: center; &#125; .pop-container &#123; width: 250px; height: 200px; background: white; border-radius: 5px; display: flex; flex-direction: column; align-items: center; justify-content: center; &#125; button &#123; width: 50px; height: 30px; border-radius: 4px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;video-container&quot;&gt; &lt;video id=&quot;video&quot; src=&quot;video.mp4&quot;&gt;&lt;/video&gt;&lt;/div&gt;&lt;div id=&quot;mask&quot;&gt; &lt;div class=&quot;pop-container&quot;&gt; &lt;p&gt;页面内有自动播放视频 请注意流量&lt;/p&gt; &lt;button onclick=&quot;playVideo()&quot;&gt;我知道了&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; function playVideo() &#123; document.getElementById(&apos;mask&apos;).style.display = &apos;none&apos;; var video = document.querySelector(&apos;#video&apos;); video.play(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 所以解决视频自动播放的一般做法是，在页面加载的时候弹框与用户产生交互，然后才能开始自动播放(如此看来，手机浏览器是真的很重视用户的流量了。） 存在的问题按照上面的方法，只要想要在手机端页面中实现 进入页面，视频立即自动播放，就必须要借助一个额外的动作去引导与用户发生一次交互，那岂不是很丑，有没有办法是可以不借助弹框呢？答案是 有的。 方案2 使用jsmpeg.jsjsmpeg是一款视频解码器，具体怎么用，可以百度相关文档，实话说我对此也不熟悉，第一次听见的时候是听说jsmpeg可以实现网页端的视频直播功能，这一次用来解决视频自动播放的需求也是借鉴别人的想法。关键代码如下：（前提：项目中已经引入了jsmpeg.min.js）12345678910111213&lt;canvas id=&quot;canvas&quot; height=&quot;750&quot; width=&quot;750&quot;&gt;&lt;/canvas&gt;页面加载完成的时候执行下面的js代码：var canvas = document.querySelector(&apos;#canvas&apos;);// 注意这里需要将video.mp4转换成ts格式的文件 才能生效var player = new JSMpeg.Player(&apos;video.ts&apos;, &#123; canvas: canvas, loop: false, autoplay: false, audio: true &#125;);player.audioOut.unlock(this.onUnlocked);player.play();// onUnlocked方法function onUnlocked() &#123; player.volume = 1;&#125; 这样即使不跟用户产生交互 视频也能自动播放了，注意点1.demo必须放在服务器上面跑才能正常加载ts文件，如果是在本地的话，不能直接拖进浏览器运行，需要起个本地服务器2.ts文件编码方式必须为MPEG编码，考虑到现在先进的ts编码方式是H.264了，之前用H.264编码的ts发现播放不了存在的问题1.这样播出的视频是没有声音的附参考链接：微信Android自动播放视频（可交互，设置层级，无控制条，非X5）ffmpeg,jsmpeg.js,.ts视频 5、补充1.虽然最后不管通过什么方法，算是实现了视频自动播放的需求，但是在真正播放的示例中，你会发现，使用video标签的时候，虽然设置了视频的宽高，但是不起作用，所以需要在video中使用下面的属性 这样就可以在固定区域播放视频了。2.借助方案1的思路，其实可以实现用户上传视频时的预览1234567891011121314&lt;input type=&quot;file&quot; id=&quot;filepicker&quot; accept=&quot;video/mp4&quot; onchange=&quot;chooseVideoInput()&quot;&gt;&lt;div class=&quot;video-container&quot;&gt; &lt;video id=&quot;video&quot; src=&quot;&quot; controls webkit-playsinline=&quot;webkit-playsinline&quot; playsinline&gt;&lt;/video&gt;&lt;/div&gt;&lt;script&gt; function chooseVideoInput() &#123; var files = document.getElementById(&apos;filepicker&apos;).files[0]; var video = document.getElementById(&apos;video&apos;); // 注意下面3行代码 var url = URL.createObjectURL(files); video.src = url; video.play(); &#125;&lt;/script&gt; 3.将mp4转换成jsmpeg可播放的ts文件的方法mac os下安装homebrew,之后使用brew install jsmpeg，运行下面命令：ffmpeg -i in.mp4 -f mpegts -codec:v mpeg1video -codec:a mp2 -b 0 out.ts (其中in.mp4和out.ts填写原视频的路径以及转出ts的路径)，亲测有效 6、总结其实关于浏览器video的问题困扰了我很久，昨日在segment上浏览到“chrome66 禁止自动播放后，有什么比较好的方法实现audio的自动播放吗”这样一个提问的时候，进去看到回答，突然想起video是不是也是一样的情况，今天看了下，果然是类似的，解了很久的疑问，所以勉励自己一定要善于发现并举一反三。上面提到的不论是解决方案或者说补充的，大概能解决一大半手机浏览器视频相关的问题，剩下的问题有机会再补充。 参考链接：chrome66 禁止自动播放后，有什么比较好的方法实现audio的自动播放吗微信Android自动播放视频（可交互，设置层级，无控制条，非X5）ffmpeg,jsmpeg.js,.ts视频mac osx 下 homebrew安装mac 系统安装使用 ffmpegHTML5音视频播放(Video,Audio)和常见的坑处理video在微信和QQ浏览器中不全屏播放解决]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[H5页面实现下载文件（apk、txt等）的三种方式]]></title>
    <url>%2F2019%2F03%2F06%2FH5%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%88apk%E3%80%81txt%E7%AD%89%EF%BC%89%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[需求描述接到的原始需求是这样的，有一个H5页面，页面中有个“点击下载”的按钮，点击之后，完成下载特定的apk。大概是下面这样的👇： 需求分析接到需求的时候我偷乐了一下，这个H5页面最大的优点是不在微信中使用（微信好坑，各种限制，基本上从微信浏览器里面实现直接下载apk是不太可能的），如果是在平常的浏览器的话，就简单多了。 功能实现于是我想到了第一种，点击下载按钮的时候改变location.href。 方法一：12// 我随便找了个apk的下载链接举个例子window.location.href = &apos;http://imtt.dd.qq.com/16891/26747DD8B125A8479AD0C9D22CA47BC9.apk?fsname=com.snda.wifilocating_4.2.91_3211.apk&amp;csr=1bbd&apos;; 拿在浏览器里面试了下，多个安卓机型都可以走通，然后我美滋滋得交付了任务，收拾收拾东西回家。然后…………截图中所说的空白页是因为我改变href为apk的下载链接，网页打开的时候会停留在一个空白页，然后一般手机的状态栏上会出现下载apk的进度条。既然不想出现空白页面的话，那不直接打开一个页面而改成在当前页打开就可以了。这时候想到iframe，借助iframe可以在原页面打开一个页面。 方法二：关键代码：12345var src = &apos;http://imtt.dd.qq.com/16891/26747DD8B125A8479AD0C9D22CA47BC9.apk?fsname=com.snda.wifilocating_4.2.91_3211.apk&amp;csr=1bbd&apos;;var iframe = document.createElement(&apos;iframe&apos;);iframe.style.display = &apos;none&apos;;iframe.src = &quot;javascript: &apos;&lt;script&gt;location.href=\&quot;&quot; + src + &quot;\&quot;&lt;\/script&gt;&apos;&quot;;document.getElementsByTagName(&apos;body&apos;)[0].appendChild(iframe); 使用iframe的话，既可以实现下载，又可以不重新打开页面，并且，对原页面的布局不会产生任何影响，最后我也是采取这种方案的。 方法三第三种方法是偶然学到的，既然使用iframe可以，那使用form一定也是可以的，form的action也可以发请求。于是改写了下第二种方法:12345var src = &apos;http://imtt.dd.qq.com/16891/26747DD8B125A8479AD0C9D22CA47BC9.apk?fsname=com.snda.wifilocating_4.2.91_3211.apk&amp;csr=1bbd&apos;;var form = document.createElement(&apos;form&apos;);form.action = src;document.getElementsByTagName(&apos;body&apos;)[0].appendChild(form);form.submit(); 以上的代码也可以实现下载apk的需求。 总结其实第二和第三种方法是扩展发挥了iframe和form的用法，单独来看，我们知道iframe可以在父页面里嵌套子页面，知道form的action可以发请求或者跳转页面，这是很常见的功能，但是不知道它们会被用在下载文件这个需求上，且产生的效果非常好。可见知识还是要融会贯通，举一反三的。写这篇的时候我去查了下iframe，原来ajax等技术未出现的时候，有段时间业内常用的长轮询的方法竟然就是借助的iframe，有兴趣的也可以研究一下。 注：此文于2018-06-20发表于技术专栏LetCodeFly，参考链接：H5页面实现下载文件（apk、txt等）的三种方式]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[页面快速定位到指定位置的几个方法]]></title>
    <url>%2F2019%2F03%2F05%2F%E9%A1%B5%E9%9D%A2%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[需求页面上有一排按钮，悬浮在窗口顶端，不随页面滑动而滑动，这一组按钮分别对应的是页面的各个部分，点击按钮，页面定位到对应的位置。 需求分析拿到这个需求，很自然的想到，解决这个最简单的方法是使用锚点（能靠HTML和css解决的，尽量不使用js 解法想到使用锚点事情就比较简单了，借用a标签的href定位，很快就写了一个Demo，完整代码：https://codepen.io/yangyang1128/pen/gKvdZw关键代码： &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;btn-container&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor1&quot;&gt;锚点1&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor2&quot;&gt;锚点2&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor3&quot;&gt;锚点3&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;anchor1&quot; class=&quot;anchor-con&quot;&gt;anchor1&lt;/div&gt; &lt;div id=&quot;anchor2&quot; class=&quot;anchor-con&quot;&gt;anchor2&lt;/div&gt; &lt;div id=&quot;anchor3&quot; class=&quot;anchor-con&quot;&gt;anchor3&lt;/div&gt; &lt;/div&gt; 这时候，点击悬浮的button，页面可以实现快速定位。 坑1点了几遍之后立马就发现了一个坑，因为按钮是悬浮的，而锚点定位，默认是定位到窗口顶端，这样定位到的区域就会有一部分被悬浮的按钮挡住如下图：原始状态：点击“锚点1”按钮之后（黄色框起来的部分就是被遮盖起来的部分）：由此引出一个问题，怎么使a标签的锚点不定位到窗口最顶端? 怎么使a标签的锚点定位到窗口的任意位置方法1：网上搜了一些方法，其中有提到使用:target，主要添加几行css #anchor1:target, #anchor2:target, #anchor3:target { padding-top: 100px; // 这里更改padding-top的值使其定位到不同地方 } 效果如下图：虽然可以实现文字的不被遮挡，但是实际上，对于固定大小的div来说，很容易影响div的内部布局，故不适用我这里的情况（然而这里的:target在其他地方作用还是非常大的。 方法二换别的思路，想了个巧办法，在每个需要定位的节点前面加一个辅助节点，辅助节点的高度可以自定，锚点的实际定位的是这个辅助节点完整代码：https://codepen.io/yangyang1128/pen/mKXzyO关键代码： &lt;div class=&quot;btn-container&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor1&quot;&gt;锚点1&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor2&quot;&gt;锚点2&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor3&quot;&gt;锚点3&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;anchor-con anchor1&quot;&gt; &lt;!--实际上定位的是这个辅助节点--&gt; &lt;div id=&quot;anchor1&quot; class=&quot;assist-div&quot;&gt;&lt;/div&gt; anchor1 &lt;/div&gt; &lt;div class=&quot;anchor-con anchor2&quot;&gt; &lt;div id=&quot;anchor2&quot; class=&quot;assist-div&quot;&gt;&lt;/div&gt; anchor2 &lt;/div&gt; &lt;div class=&quot;anchor-con anchor3&quot;&gt; &lt;div id=&quot;anchor3&quot; class=&quot;assist-div&quot;&gt;&lt;/div&gt; anchor3 &lt;/div&gt; 辅助节点的css: .assist-div { width: 1px; height: 1px; position: absolute; top: -100px; // 这里可以设任意高度 对应锚点最后离窗口顶端的距离 left: 0; } 这个方法的优点：(一)辅助节点可以绝对定位 不影响布局(二)改变辅助节点的top值 可以实现锚点定位到窗口任意位置最后效果截图：(点击了“锚点2“按钮) 坑2正当我美滋滋的交付任务，坐等1h之后的聚餐的时候，PM来找我说，不行，移动端打开的时候，我切换点了几下悬浮的按钮之后，要点很多下返回键才能退出页面。我：对啊因为每点一次按钮就在浏览器记录里面添加一条记录PM：这不行 需要解决掉。。。这是个问题，需要用户点击很多下才能退出页面体验确实不好，如果想要用户点击一次就退出页面，就得始终保持history只有一条记录，但是a标签跳转的话自动往history加一条记录，我也不能对此做什么。。。。这时候不得不使用js了，我盯着锚点看了会儿(实际上看了半小时:) )发现: 例如http://shili.com/Demo.html#content1 这样的url，是可以直接定位到http://shili.com/Demo.html 这个页面的id为content1的节点处的，这样的话，我不使用a标签，直接使用js去动态改变url后面的#id 的id，也可以实现定位的效果，并且还能实现浏览器只保存一条记录。 完整代码：https://codepen.io/yangyang1128/pen/yEvQPe关键代码： 去除a标签，改为使用div，并添加click： &lt;div class=&quot;btn-container&quot;&gt; &lt;div class=&quot;btn&quot; onclick=&quot;goToAnchor(&apos;#anchor1&apos;)&quot;&gt;锚点1&lt;/div&gt; &lt;div class=&quot;btn&quot; onclick=&quot;goToAnchor(&apos;#anchor2&apos;)&quot;&gt;锚点2&lt;/div&gt; &lt;div class=&quot;btn&quot; onclick=&quot;goToAnchor(&apos;#anchor3&apos;)&quot;&gt;锚点3&lt;/div&gt; &lt;/div&gt; function goToAnchor(anchorId) { // 使用replace方法可以保证前一次浏览不会在浏览器中保留记录 window.location.replace(window.location.href.split(&apos;#&apos;)[0] + anchorId); } 至此，需求就完成了。但是就页面定位到指定位置其实还有更好的办法，就是使用js去获取指定位置的offsetTop，这样的话还可以加滑动动画，使定位的这个过程比较平滑。我没有使用这个方法是因为，一我开始就一心想使用锚点结果只能遇坑填坑，二我的页面中有很多折叠的部分（类似于手风琴效果），所以每次的offsetTop都可能是不一样的，点击时都需要去获取offsetTop的值再移动，比较麻烦而且耗性能。（emmm虽然我一开始就抗拒使用js去解决，最后还是使用了，但是抉择之下还是使用性能消耗小的比较好这里也丢一下采用上面这个方法的关键代码 document.getElementById(&apos;content&apos;).scrollTop = document.getElementById(anchorId).offsetTop - 100; 注：此文于2018-06-20发表于技术专栏LetCodeFly，参考链接：页面快速定位到指定位置的几个方法]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单行文字垂直/水平跑马灯效果]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%8D%95%E8%A1%8C%E6%96%87%E5%AD%97%E5%9E%82%E7%9B%B4-%E6%B0%B4%E5%B9%B3%E8%B7%91%E9%A9%AC%E7%81%AF%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[需求描述接到的需求是这样的：跑马灯效果 一次展示一行文字 循环滚动 文字滚动到视野中停留一秒后滚出。静态效果如下图，文字从下往上或者从右往左滚动，滚动到此位置时停留一秒（不会传动图…网络上有比较多的多行文字循环滚动的demo,找了一下好像能满足单行并且可停留一秒的比较少（emmm可能我没认真找下面贴出我的最终解决方案。 解决方案垂直方向滚动使用一个定时器 不断改变最外层div的scrollTop，为了能循环滚动，增加一个与con1一样的con2PS：这里的time选用1000/60是因为想要模拟window.requestAnimationFrame(一般1000ms60帧，当然了，你也可以直接使用requestAnimationFrame代替setInterval，效果更好1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单行文字垂直跑马灯效果&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; ul,li&#123; list-style:none; display:block; margin: 0; padding: 0; &#125; #loop-show-box &#123; width: 300px; height: 25px; line-height: 25px; background: red; position: absolute; top: 0; left: 0; right: 0; overflow: hidden; &#125; .li-style &#123; width: 100%; height: 25px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;loop-show-box&quot;&gt; &lt;ul id=&quot;con1&quot;&gt; &lt;li class=&quot;li-style&quot;&gt;测试1号&lt;/li&gt; &lt;li class=&quot;li-style&quot;&gt;测试2号&lt;/li&gt; &lt;li class=&quot;li-style&quot;&gt;测试3号&lt;/li&gt; &lt;li class=&quot;li-style&quot;&gt;测试4号&lt;/li&gt; &lt;/ul&gt; &lt;ul id=&quot;con2&quot;&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var area = document.getElementById(&apos;loop-show-box&apos;); var con1 = document.getElementById(&apos;con1&apos;); var con2 = document.getElementById(&apos;con2&apos;); var mytimer1 = null; var mytimer = null; var time = 1000 / 60; con2.innerHTML = con1.innerHTML; function scrollUp () &#123; if (area.scrollTop &gt;= con1.offsetHeight) &#123; area.scrollTop = 0; &#125; else &#123; if (area.scrollTop % 25 == 0) &#123; clearInterval(mytimer); clearInterval(mytimer1); mytimer1 = setTimeout(function () &#123; mytimer = setInterval(scrollUp, time); &#125;, 1000); &#125; area.scrollTop++; &#125; &#125; mytimer = setInterval(scrollUp, time);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 水平方向滚动水平方法滚动的具体实现其实跟垂直方向类似的，不同的是要改变的是容器的scrollLeft1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单行文字水平跑马灯效果&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; .container &#123; width: 400px; height: 25px; display: flex; flex-direction: row; justify-content: center; align-items: center; margin: 100px auto; &#125; .icon &#123; width: 15px; margin-right: 15px; &#125; #loop-show-box &#123; width: 300px; height: 25px; line-height: 25px; background: red; overflow: auto; white-space: nowrap; &#125; .li-style &#123; width: 300px; height: 25px; text-align: left; /*使用inline-block的时候两个item之间会存在间距（当然了你可以把它们写在一行以去除这样的间距*/ display: inline-flex; &#125; #con1,#con2 &#123; display: inline-flex; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;img src=&quot;img/horn.png&quot; class=&quot;icon&quot;&gt; &lt;div id=&quot;loop-show-box&quot;&gt; &lt;div id=&quot;con1&quot;&gt; &lt;div class=&quot;li-style&quot;&gt;测试1号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试2号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试3号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试4号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试5号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试6号&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;con2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var area = document.getElementById(&apos;loop-show-box&apos;); var con1 = document.getElementById(&apos;con1&apos;); var con2 = document.getElementById(&apos;con2&apos;); var mytimer1 = null; var mytimer = null; var time = 1000 / 60; con2.innerHTML = con1.innerHTML; function scrollUp () &#123; if (area.scrollLeft &gt;= con1.offsetWidth) &#123; area.scrollLeft = 0; &#125; else &#123; // 可根据想要的速度调节步长 area.scrollLeft += 2; if (area.scrollLeft % 300 == 0) &#123; clearInterval(mytimer); clearInterval(mytimer1); mytimer1 = setTimeout(function () &#123; mytimer = setInterval(scrollUp, time); &#125;, 1000); &#125; &#125; &#125; mytimer1 = setTimeout(function () &#123; mytimer = setInterval(scrollUp, time); &#125;, 1000)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注：此文于2018-06-07发表于技术专栏LetCodeFly，参考链接：单行文字垂直/水平跑马灯效果]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[H5 Video 使用网络地址时获取其大小和第一帧图片]]></title>
    <url>%2F2019%2F03%2F04%2FH5-Video-%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E6%97%B6%E8%8E%B7%E5%8F%96%E5%85%B6%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%AC%AC%E4%B8%80%E5%B8%A7%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[问题描述某一天接了个需求，要求前端获取视频文件的大小、时长以及第一帧图片传给后端服务器存储，这样有两种情况，一种是通过input上传本地视频文件，一种是给出视频的网络地址，将其直接赋值给video标签的src属性。 使用input标签上传本地视频使用&lt;input type=&quot;file&quot;&gt;上传的视频文件，这都好说，有了file文件对象，可以随意操作，获取其size，再通过FileReader对象来处理file。这里附上一个demo(使用vue)123456789101112131415161718192021222324252627&lt;img id=&quot;video-poster&quot; alt=&quot;视频封面&quot; /&gt;&lt;input type=&quot;file&quot; id=&quot;upload-video&quot; accept=&quot;video/*&quot; @change=&quot;uploadVideo&quot; /&gt;&lt;video id=&quot;video&quot; controls /&gt;```json```javascript uploadVideo: function () &#123; var video_file = document.getElementById(&apos;upload-video&apos;).files[0]; // 这里可以打印出视频文件的size大小 console.log(video_file.size); if (!video_file) return; var reader = new FileReader(); reader.onload = function () &#123; var videoDom = document.getElementById(&apos;video&apos;); videoDom.onloadeddata = function () &#123; // 这里可以打印视频时长 console.log(this.duration); // 这里取得视频封面 var canvas = document.createElement(&apos;canvas&apos;); canvas.width = 300; canvas.height = 300 * this.videoHeight / this.videoWidth; canvas.getContext(&apos;2d&apos;).drawImage(this, 0, 0, canvas.width, canvas.height); document.getElementById(&apos;video-poster&apos;).src = canvas.toDataURL(); &#125; videoDom.src = reader.result; &#125; reader.readAsDataURL(video_file); &#125; 使用网络地址访问视频现在需求变一下，视频不是从本地引入的，而是后端服务器直接给前端返回视频src，前端在对视频播放之后需要给后端服务器上传视频的大小，时长，第一帧图片，我内心：？？？？时长倒是好处理，可以借鉴第一种情况，通过监听onloadeddata的方法获取，问题来了，大小怎么获取？？上一面文章里面提供了一种canvas图片跨域的方法https://segmentfault.com/a/1190000014478087，最后一种方法也可以用来解决这里的需求，通过发起一个ajax请求，将网络地址的视频下载为本地blob视频文件，再将blob文件赋值给视频的src12345678910111213141516171819202122232425function getVideoBlob (url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, url, true); xhr.responseType = &apos;blob&apos;; xhr.onload = function () &#123; if (this.status == 200) &#123; // 获取视频文件大小 console.log(this.response.size / 1000000 + &apos;MB&apos;); spiderVideoResponse = this.response; // 将response赋值为Video的src 或者也可以使用preView转换为base64的格式 // 截取第一帧的图片方法跟第一种情况一样，而且还解决了获取图片时跨域的问题 一举两得 video.src = URL.createObjectURL(this.response); &#125; &#125;; xhr.send();&#125;function preView (url) &#123; let reader = new FileReader(); getImageBlob(url, function (blob) &#123; reader.readAsDataURL(blob); &#125;); reader.onload = function (e) &#123; console.log(e.loaded) &#125;&#125; 这里面根据视频的两种情况分别提供了解决方法，可根据自身情况选取，自封为“最全解决方法”hhhh 注：此文于2018-04-20发表于技术专栏LetCodeFly，参考链接：H5 Video 使用网络地址时获取其大小和第一帧图片]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[canvas图片绘制跨域问题解决方案黑科技版]]></title>
    <url>%2F2019%2F03%2F04%2Fcanvas%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%BB%91%E7%A7%91%E6%8A%80%E7%89%88%2F</url>
    <content type="text"><![CDATA[图片跨域问题的一般解决方法注：此文2018-04-19发表于个人技术专栏LetCodeFly指路：canvas图片绘制跨域问题解决方案Tainted canvases may not be exported.当使用canvas绘制网络图片的时候，经常会出现“Tainted canvases may not be exported”报错，上网搜一下解决方案，应该给的都是给img添加crossOrigin属性，尝试了一下，确实可用。看下面的一个例子：html代码：12&lt;canvas id=&quot;canvas&quot; style=&quot;display: none&quot;&gt;&lt;/canvas&gt;&lt;img id=&quot;canvasImg&quot; /&gt; javascript代码：1234567891011var img = new Image();img.setAttribute(&apos;crossOrigin&apos;, &apos;anonymous&apos;);var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&apos;2d&apos;);img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height + 200; ctx.drawImage(img, 0, 0); document.getElementById(&apos;canvasImg&apos;).src = canvas.toDataURL(&quot;image/jpeg&quot;, 1); &#125;img.src = &apos;http://img.hb.aicdn.com/38d8f519b3f464a80d85ed9632fed904ed0181f41d632-ZHrigO_fw658&apos;; 这样就可以正常画出图片了。 微信图片的问题但是我发现这个方法用于绘制微信头像的时候有概率会出现问题，当然了这里面指的是将图片的网络地址直接赋值给图片的src。【之所以说有概率会出现问题是因为我通过上面的方法去完成需求的时候并没有画出头像（微信头像放在wx.qlogo.cn域名下，然而我今天准备写这篇文章的时候突然就可以了，见鬼当时的时候我们找了很多方法，发现，在头像url后面加上时间戳的话就可以了【emmm神操作即：1img.src = &apos;http://wx.qlogo.cn/mmopen/vi_32/RnLIHfXibgFHlticiclzflpriaLsC3TS9b2Sbj05Wh3vGlhcFutt18dfkXGUt8x11e4q2KHlX4EHHaBb6XylLQW1kQ/0?timeStamp=&apos;+new Date(); 其他的解法今天找了个新的方法去解决canvas图片跨域的问题：将文件读入到blob文件对象，然后使用URL.createObjectURL转换成src可用的地址123456789101112131415161718192021222324252627282930313233//直接读成blob文件对象function getImageBlob (url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open('get', url, true); xhr.responseType = 'blob'; xhr.onload = function () &#123; if (this.status == 200) &#123; imgResponse = this.response; //这里面可以直接通过URL的api将其转换，然后赋值给img.src //也可以使用下面的preView方法将其转换成base64之后再赋值 img.src = URL.createObjectURL(this.response); &#125; &#125;; xhr.send(); &#125; //这里面将blob转换成base64 function preView (url) &#123; let reader = new FileReader(); getImageBlob(url, function (blob) &#123; reader.readAsDataURL(blob); &#125;); reader.onload = function (e) &#123; console.log(e.loaded) &#125; &#125; img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height + 200; ctx.drawImage(img, 0, 0); document.getElementById('canvasImg').src = canvas.toDataURL("image/jpeg", 1); &#125; var imgResponse = ''; getImageBlob('http://wx.qlogo.cn/mmopen/vi_32/RnLIHfXibgFHlticiclzflpriaLsC3TS9b2Sbj05Wh3vGlhcFutt18dfkXGUt8x11e4q2KHlX4EHHaBb6XylLQW1kQ/0');]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[测试文章]]></title>
    <url>%2F2019%2F02%2F12%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[hello欢迎来到封闭货车]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
