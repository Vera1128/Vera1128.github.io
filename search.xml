<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[H5 Video 使用网络地址时获取其大小和第一帧图片]]></title>
    <url>%2F2019%2F03%2F04%2FH5-Video-%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E6%97%B6%E8%8E%B7%E5%8F%96%E5%85%B6%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%AC%AC%E4%B8%80%E5%B8%A7%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[问题描述某一天接了个需求，要求前端获取视频文件的大小、时长以及第一帧图片传给后端服务器存储，这样有两种情况，一种是通过input上传本地视频文件，一种是给出视频的网络地址，将其直接赋值给video标签的src属性。 使用input标签上传本地视频使用&lt;input type=&quot;file&quot;&gt;上传的视频文件，这都好说，有了file文件对象，可以随意操作，获取其size，再通过FileReader对象来处理file。这里附上一个demo(使用vue)123456789101112131415161718192021222324252627&lt;img id=&quot;video-poster&quot; alt=&quot;视频封面&quot; /&gt;&lt;input type=&quot;file&quot; id=&quot;upload-video&quot; accept=&quot;video/*&quot; @change=&quot;uploadVideo&quot; /&gt;&lt;video id=&quot;video&quot; controls /&gt;```json```javascript uploadVideo: function () &#123; var video_file = document.getElementById(&apos;upload-video&apos;).files[0]; // 这里可以打印出视频文件的size大小 console.log(video_file.size); if (!video_file) return; var reader = new FileReader(); reader.onload = function () &#123; var videoDom = document.getElementById(&apos;video&apos;); videoDom.onloadeddata = function () &#123; // 这里可以打印视频时长 console.log(this.duration); // 这里取得视频封面 var canvas = document.createElement(&apos;canvas&apos;); canvas.width = 300; canvas.height = 300 * this.videoHeight / this.videoWidth; canvas.getContext(&apos;2d&apos;).drawImage(this, 0, 0, canvas.width, canvas.height); document.getElementById(&apos;video-poster&apos;).src = canvas.toDataURL(); &#125; videoDom.src = reader.result; &#125; reader.readAsDataURL(video_file); &#125; 使用网络地址访问视频现在需求变一下，视频不是从本地引入的，而是后端服务器直接给前端返回视频src，前端在对视频播放之后需要给后端服务器上传视频的大小，时长，第一帧图片，我内心：？？？？时长倒是好处理，可以借鉴第一种情况，通过监听onloadeddata的方法获取，问题来了，大小怎么获取？？上一面文章里面提供了一种canvas图片跨域的方法https://segmentfault.com/a/1190000014478087，最后一种方法也可以用来解决这里的需求，通过发起一个ajax请求，将网络地址的视频下载为本地blob视频文件，再将blob文件赋值给视频的src12345678910111213141516171819202122232425function getVideoBlob (url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, url, true); xhr.responseType = &apos;blob&apos;; xhr.onload = function () &#123; if (this.status == 200) &#123; // 获取视频文件大小 console.log(this.response.size / 1000000 + &apos;MB&apos;); spiderVideoResponse = this.response; // 将response赋值为Video的src 或者也可以使用preView转换为base64的格式 // 截取第一帧的图片方法跟第一种情况一样，而且还解决了获取图片时跨域的问题 一举两得 video.src = URL.createObjectURL(this.response); &#125; &#125;; xhr.send();&#125;function preView (url) &#123; let reader = new FileReader(); getImageBlob(url, function (blob) &#123; reader.readAsDataURL(blob); &#125;); reader.onload = function (e) &#123; console.log(e.loaded) &#125;&#125; 这里面根据视频的两种情况分别提供了解决方法，可根据自身情况选取，自封为“最全解决方法”hhhh 注此文于2018-04-20发表于技术专栏LetCodeFly，参考链接：H5 Video 使用网络地址时获取其大小和第一帧图片]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[canvas图片绘制跨域问题解决方案黑科技版]]></title>
    <url>%2F2019%2F03%2F04%2Fcanvas%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%BB%91%E7%A7%91%E6%8A%80%E7%89%88%2F</url>
    <content type="text"><![CDATA[图片跨域问题的一般解决方法注：此文2018-04-19发表于个人技术专栏LetCodeFly指路：canvas图片绘制跨域问题解决方案Tainted canvases may not be exported.当使用canvas绘制网络图片的时候，经常会出现“Tainted canvases may not be exported”报错，上网搜一下解决方案，应该给的都是给img添加crossOrigin属性，尝试了一下，确实可用。看下面的一个例子：html代码：12&lt;canvas id=&quot;canvas&quot; style=&quot;display: none&quot;&gt;&lt;/canvas&gt;&lt;img id=&quot;canvasImg&quot; /&gt; javascript代码：1234567891011var img = new Image();img.setAttribute(&apos;crossOrigin&apos;, &apos;anonymous&apos;);var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&apos;2d&apos;);img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height + 200; ctx.drawImage(img, 0, 0); document.getElementById(&apos;canvasImg&apos;).src = canvas.toDataURL(&quot;image/jpeg&quot;, 1); &#125;img.src = &apos;http://img.hb.aicdn.com/38d8f519b3f464a80d85ed9632fed904ed0181f41d632-ZHrigO_fw658&apos;; 这样就可以正常画出图片了。 微信图片的问题但是我发现这个方法用于绘制微信头像的时候有概率会出现问题，当然了这里面指的是将图片的网络地址直接赋值给图片的src。【之所以说有概率会出现问题是因为我通过上面的方法去完成需求的时候并没有画出头像（微信头像放在wx.qlogo.cn域名下，然而我今天准备写这篇文章的时候突然就可以了，见鬼当时的时候我们找了很多方法，发现，在头像url后面加上时间戳的话就可以了【emmm神操作即：1img.src = &apos;http://wx.qlogo.cn/mmopen/vi_32/RnLIHfXibgFHlticiclzflpriaLsC3TS9b2Sbj05Wh3vGlhcFutt18dfkXGUt8x11e4q2KHlX4EHHaBb6XylLQW1kQ/0?timeStamp=&apos;+new Date(); 其他的解法今天找了个新的方法去解决canvas图片跨域的问题：将文件读入到blob文件对象，然后使用URL.createObjectURL转换成src可用的地址123456789101112131415161718192021222324252627282930313233//直接读成blob文件对象function getImageBlob (url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open('get', url, true); xhr.responseType = 'blob'; xhr.onload = function () &#123; if (this.status == 200) &#123; imgResponse = this.response; //这里面可以直接通过URL的api将其转换，然后赋值给img.src //也可以使用下面的preView方法将其转换成base64之后再赋值 img.src = URL.createObjectURL(this.response); &#125; &#125;; xhr.send(); &#125; //这里面将blob转换成base64 function preView (url) &#123; let reader = new FileReader(); getImageBlob(url, function (blob) &#123; reader.readAsDataURL(blob); &#125;); reader.onload = function (e) &#123; console.log(e.loaded) &#125; &#125; img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height + 200; ctx.drawImage(img, 0, 0); document.getElementById('canvasImg').src = canvas.toDataURL("image/jpeg", 1); &#125; var imgResponse = ''; getImageBlob('http://wx.qlogo.cn/mmopen/vi_32/RnLIHfXibgFHlticiclzflpriaLsC3TS9b2Sbj05Wh3vGlhcFutt18dfkXGUt8x11e4q2KHlX4EHHaBb6XylLQW1kQ/0');]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[测试文章]]></title>
    <url>%2F2019%2F02%2F12%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[hello欢迎来到封闭货车 1封闭货车封闭货车封闭货车封闭货车封闭货车 1封闭货车封闭货车封闭货车封闭货车封闭货车 1封闭货车封闭货车封闭货车封闭货车封闭货车 1封闭货车封闭货车封闭货车封闭货车封闭货车 哈哈哈这是测试文章 这是小标题哇 你知道嘛这是大标题]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
