<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[页面快速定位到指定位置的几个方法]]></title>
    <url>%2F2019%2F03%2F05%2F%E9%A1%B5%E9%9D%A2%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[需求页面上有一排按钮，悬浮在窗口顶端，不随页面滑动而滑动，这一组按钮分别对应的是页面的各个部分，点击按钮，页面定位到对应的位置。 需求分析拿到这个需求，很自然的想到，解决这个最简单的方法是使用锚点（能靠HTML和css解决的，尽量不使用js 解法想到使用锚点事情就比较简单了，借用a标签的href定位，很快就写了一个Demo，完整代码：https://codepen.io/yangyang1128/pen/gKvdZw关键代码： &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;btn-container&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor1&quot;&gt;锚点1&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor2&quot;&gt;锚点2&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor3&quot;&gt;锚点3&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;anchor1&quot; class=&quot;anchor-con&quot;&gt;anchor1&lt;/div&gt; &lt;div id=&quot;anchor2&quot; class=&quot;anchor-con&quot;&gt;anchor2&lt;/div&gt; &lt;div id=&quot;anchor3&quot; class=&quot;anchor-con&quot;&gt;anchor3&lt;/div&gt; &lt;/div&gt; 这时候，点击悬浮的button，页面可以实现快速定位。 坑1点了几遍之后立马就发现了一个坑，因为按钮是悬浮的，而锚点定位，默认是定位到窗口顶端，这样定位到的区域就会有一部分被悬浮的按钮挡住如下图：原始状态：点击“锚点1”按钮之后（黄色框起来的部分就是被遮盖起来的部分）：由此引出一个问题，怎么使a标签的锚点不定位到窗口最顶端? 怎么使a标签的锚点定位到窗口的任意位置方法1：网上搜了一些方法，其中有提到使用:target，主要添加几行css #anchor1:target, #anchor2:target, #anchor3:target { padding-top: 100px; // 这里更改padding-top的值使其定位到不同地方 } 效果如下图：虽然可以实现文字的不被遮挡，但是实际上，对于固定大小的div来说，很容易影响div的内部布局，故不适用我这里的情况（然而这里的:target在其他地方作用还是非常大的。 方法二换别的思路，想了个巧办法，在每个需要定位的节点前面加一个辅助节点，辅助节点的高度可以自定，锚点的实际定位的是这个辅助节点完整代码：https://codepen.io/yangyang1128/pen/mKXzyO关键代码： &lt;div class=&quot;btn-container&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor1&quot;&gt;锚点1&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor2&quot;&gt;锚点2&lt;/a&gt; &lt;a class=&quot;btn&quot; href=&quot;#anchor3&quot;&gt;锚点3&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;anchor-con anchor1&quot;&gt; &lt;!--实际上定位的是这个辅助节点--&gt; &lt;div id=&quot;anchor1&quot; class=&quot;assist-div&quot;&gt;&lt;/div&gt; anchor1 &lt;/div&gt; &lt;div class=&quot;anchor-con anchor2&quot;&gt; &lt;div id=&quot;anchor2&quot; class=&quot;assist-div&quot;&gt;&lt;/div&gt; anchor2 &lt;/div&gt; &lt;div class=&quot;anchor-con anchor3&quot;&gt; &lt;div id=&quot;anchor3&quot; class=&quot;assist-div&quot;&gt;&lt;/div&gt; anchor3 &lt;/div&gt; 辅助节点的css: .assist-div { width: 1px; height: 1px; position: absolute; top: -100px; // 这里可以设任意高度 对应锚点最后离窗口顶端的距离 left: 0; } 这个方法的优点：(一)辅助节点可以绝对定位 不影响布局(二)改变辅助节点的top值 可以实现锚点定位到窗口任意位置最后效果截图：(点击了“锚点2“按钮) 坑2正当我美滋滋的交付任务，坐等1h之后的聚餐的时候，PM来找我说，不行，移动端打开的时候，我切换点了几下悬浮的按钮之后，要点很多下返回键才能退出页面。我：对啊因为每点一次按钮就在浏览器记录里面添加一条记录PM：这不行 需要解决掉。。。这是个问题，需要用户点击很多下才能退出页面体验确实不好，如果想要用户点击一次就退出页面，就得始终保持history只有一条记录，但是a标签跳转的话自动往history加一条记录，我也不能对此做什么。。。。这时候不得不使用js了，我盯着锚点看了会儿(实际上看了半小时:) )发现: 例如http://shili.com/Demo.html#content1 这样的url，是可以直接定位到http://shili.com/Demo.html 这个页面的id为content1的节点处的，这样的话，我不使用a标签，直接使用js去动态改变url后面的#id 的id，也可以实现定位的效果，并且还能实现浏览器只保存一条记录。 完整代码：https://codepen.io/yangyang1128/pen/yEvQPe关键代码： 去除a标签，改为使用div，并添加click： &lt;div class=&quot;btn-container&quot;&gt; &lt;div class=&quot;btn&quot; onclick=&quot;goToAnchor(&apos;#anchor1&apos;)&quot;&gt;锚点1&lt;/div&gt; &lt;div class=&quot;btn&quot; onclick=&quot;goToAnchor(&apos;#anchor2&apos;)&quot;&gt;锚点2&lt;/div&gt; &lt;div class=&quot;btn&quot; onclick=&quot;goToAnchor(&apos;#anchor3&apos;)&quot;&gt;锚点3&lt;/div&gt; &lt;/div&gt; function goToAnchor(anchorId) { // 使用replace方法可以保证前一次浏览不会在浏览器中保留记录 window.location.replace(window.location.href.split(&apos;#&apos;)[0] + anchorId); } 至此，需求就完成了。但是就页面定位到指定位置其实还有更好的办法，就是使用js去获取指定位置的offsetTop，这样的话还可以加滑动动画，使定位的这个过程比较平滑。我没有使用这个方法是因为，一我开始就一心想使用锚点结果只能遇坑填坑，二我的页面中有很多折叠的部分（类似于手风琴效果），所以每次的offsetTop都可能是不一样的，点击时都需要去获取offsetTop的值再移动，比较麻烦而且耗性能。（emmm虽然我一开始就抗拒使用js去解决，最后还是使用了，但是抉择之下还是使用性能消耗小的比较好这里也丢一下采用上面这个方法的关键代码 document.getElementById(&apos;content&apos;).scrollTop = document.getElementById(anchorId).offsetTop - 100;]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单行文字垂直/水平跑马灯效果]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%8D%95%E8%A1%8C%E6%96%87%E5%AD%97%E5%9E%82%E7%9B%B4-%E6%B0%B4%E5%B9%B3%E8%B7%91%E9%A9%AC%E7%81%AF%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[需求描述接到的需求是这样的：跑马灯效果 一次展示一行文字 循环滚动 文字滚动到视野中停留一秒后滚出。静态效果如下图，文字从下往上或者从右往左滚动，滚动到此位置时停留一秒（不会传动图…网络上有比较多的多行文字循环滚动的demo,找了一下好像能满足单行并且可停留一秒的比较少（emmm可能我没认真找下面贴出我的最终解决方案。 解决方案垂直方向滚动使用一个定时器 不断改变最外层div的scrollTop，为了能循环滚动，增加一个与con1一样的con2PS：这里的time选用1000/60是因为想要模拟window.requestAnimationFrame(一般1000ms60帧，当然了，你也可以直接使用requestAnimationFrame代替setInterval，效果更好1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单行文字垂直跑马灯效果&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; ul,li&#123; list-style:none; display:block; margin: 0; padding: 0; &#125; #loop-show-box &#123; width: 300px; height: 25px; line-height: 25px; background: red; position: absolute; top: 0; left: 0; right: 0; overflow: hidden; &#125; .li-style &#123; width: 100%; height: 25px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;loop-show-box&quot;&gt; &lt;ul id=&quot;con1&quot;&gt; &lt;li class=&quot;li-style&quot;&gt;测试1号&lt;/li&gt; &lt;li class=&quot;li-style&quot;&gt;测试2号&lt;/li&gt; &lt;li class=&quot;li-style&quot;&gt;测试3号&lt;/li&gt; &lt;li class=&quot;li-style&quot;&gt;测试4号&lt;/li&gt; &lt;/ul&gt; &lt;ul id=&quot;con2&quot;&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var area = document.getElementById(&apos;loop-show-box&apos;); var con1 = document.getElementById(&apos;con1&apos;); var con2 = document.getElementById(&apos;con2&apos;); var mytimer1 = null; var mytimer = null; var time = 1000 / 60; con2.innerHTML = con1.innerHTML; function scrollUp () &#123; if (area.scrollTop &gt;= con1.offsetHeight) &#123; area.scrollTop = 0; &#125; else &#123; if (area.scrollTop % 25 == 0) &#123; clearInterval(mytimer); clearInterval(mytimer1); mytimer1 = setTimeout(function () &#123; mytimer = setInterval(scrollUp, time); &#125;, 1000); &#125; area.scrollTop++; &#125; &#125; mytimer = setInterval(scrollUp, time);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 水平方向滚动水平方法滚动的具体实现其实跟垂直方向类似的，不同的是要改变的是容器的scrollLeft1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;单行文字水平跑马灯效果&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; .container &#123; width: 400px; height: 25px; display: flex; flex-direction: row; justify-content: center; align-items: center; margin: 100px auto; &#125; .icon &#123; width: 15px; margin-right: 15px; &#125; #loop-show-box &#123; width: 300px; height: 25px; line-height: 25px; background: red; overflow: auto; white-space: nowrap; &#125; .li-style &#123; width: 300px; height: 25px; text-align: left; /*使用inline-block的时候两个item之间会存在间距（当然了你可以把它们写在一行以去除这样的间距*/ display: inline-flex; &#125; #con1,#con2 &#123; display: inline-flex; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;img src=&quot;img/horn.png&quot; class=&quot;icon&quot;&gt; &lt;div id=&quot;loop-show-box&quot;&gt; &lt;div id=&quot;con1&quot;&gt; &lt;div class=&quot;li-style&quot;&gt;测试1号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试2号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试3号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试4号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试5号&lt;/div&gt; &lt;div class=&quot;li-style&quot;&gt;测试6号&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;con2&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var area = document.getElementById(&apos;loop-show-box&apos;); var con1 = document.getElementById(&apos;con1&apos;); var con2 = document.getElementById(&apos;con2&apos;); var mytimer1 = null; var mytimer = null; var time = 1000 / 60; con2.innerHTML = con1.innerHTML; function scrollUp () &#123; if (area.scrollLeft &gt;= con1.offsetWidth) &#123; area.scrollLeft = 0; &#125; else &#123; // 可根据想要的速度调节步长 area.scrollLeft += 2; if (area.scrollLeft % 300 == 0) &#123; clearInterval(mytimer); clearInterval(mytimer1); mytimer1 = setTimeout(function () &#123; mytimer = setInterval(scrollUp, time); &#125;, 1000); &#125; &#125; &#125; mytimer1 = setTimeout(function () &#123; mytimer = setInterval(scrollUp, time); &#125;, 1000)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注：此文于2018-06-07发表于技术专栏LetCodeFly，参考链接：单行文字垂直/水平跑马灯效果]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[H5 Video 使用网络地址时获取其大小和第一帧图片]]></title>
    <url>%2F2019%2F03%2F04%2FH5-Video-%E4%BD%BF%E7%94%A8%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E6%97%B6%E8%8E%B7%E5%8F%96%E5%85%B6%E5%A4%A7%E5%B0%8F%E5%92%8C%E7%AC%AC%E4%B8%80%E5%B8%A7%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[问题描述某一天接了个需求，要求前端获取视频文件的大小、时长以及第一帧图片传给后端服务器存储，这样有两种情况，一种是通过input上传本地视频文件，一种是给出视频的网络地址，将其直接赋值给video标签的src属性。 使用input标签上传本地视频使用&lt;input type=&quot;file&quot;&gt;上传的视频文件，这都好说，有了file文件对象，可以随意操作，获取其size，再通过FileReader对象来处理file。这里附上一个demo(使用vue)123456789101112131415161718192021222324252627&lt;img id=&quot;video-poster&quot; alt=&quot;视频封面&quot; /&gt;&lt;input type=&quot;file&quot; id=&quot;upload-video&quot; accept=&quot;video/*&quot; @change=&quot;uploadVideo&quot; /&gt;&lt;video id=&quot;video&quot; controls /&gt;```json```javascript uploadVideo: function () &#123; var video_file = document.getElementById(&apos;upload-video&apos;).files[0]; // 这里可以打印出视频文件的size大小 console.log(video_file.size); if (!video_file) return; var reader = new FileReader(); reader.onload = function () &#123; var videoDom = document.getElementById(&apos;video&apos;); videoDom.onloadeddata = function () &#123; // 这里可以打印视频时长 console.log(this.duration); // 这里取得视频封面 var canvas = document.createElement(&apos;canvas&apos;); canvas.width = 300; canvas.height = 300 * this.videoHeight / this.videoWidth; canvas.getContext(&apos;2d&apos;).drawImage(this, 0, 0, canvas.width, canvas.height); document.getElementById(&apos;video-poster&apos;).src = canvas.toDataURL(); &#125; videoDom.src = reader.result; &#125; reader.readAsDataURL(video_file); &#125; 使用网络地址访问视频现在需求变一下，视频不是从本地引入的，而是后端服务器直接给前端返回视频src，前端在对视频播放之后需要给后端服务器上传视频的大小，时长，第一帧图片，我内心：？？？？时长倒是好处理，可以借鉴第一种情况，通过监听onloadeddata的方法获取，问题来了，大小怎么获取？？上一面文章里面提供了一种canvas图片跨域的方法https://segmentfault.com/a/1190000014478087，最后一种方法也可以用来解决这里的需求，通过发起一个ajax请求，将网络地址的视频下载为本地blob视频文件，再将blob文件赋值给视频的src12345678910111213141516171819202122232425function getVideoBlob (url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, url, true); xhr.responseType = &apos;blob&apos;; xhr.onload = function () &#123; if (this.status == 200) &#123; // 获取视频文件大小 console.log(this.response.size / 1000000 + &apos;MB&apos;); spiderVideoResponse = this.response; // 将response赋值为Video的src 或者也可以使用preView转换为base64的格式 // 截取第一帧的图片方法跟第一种情况一样，而且还解决了获取图片时跨域的问题 一举两得 video.src = URL.createObjectURL(this.response); &#125; &#125;; xhr.send();&#125;function preView (url) &#123; let reader = new FileReader(); getImageBlob(url, function (blob) &#123; reader.readAsDataURL(blob); &#125;); reader.onload = function (e) &#123; console.log(e.loaded) &#125;&#125; 这里面根据视频的两种情况分别提供了解决方法，可根据自身情况选取，自封为“最全解决方法”hhhh 注：此文于2018-04-20发表于技术专栏LetCodeFly，参考链接：H5 Video 使用网络地址时获取其大小和第一帧图片]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[canvas图片绘制跨域问题解决方案黑科技版]]></title>
    <url>%2F2019%2F03%2F04%2Fcanvas%E5%9B%BE%E7%89%87%E7%BB%98%E5%88%B6%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%BB%91%E7%A7%91%E6%8A%80%E7%89%88%2F</url>
    <content type="text"><![CDATA[图片跨域问题的一般解决方法注：此文2018-04-19发表于个人技术专栏LetCodeFly指路：canvas图片绘制跨域问题解决方案Tainted canvases may not be exported.当使用canvas绘制网络图片的时候，经常会出现“Tainted canvases may not be exported”报错，上网搜一下解决方案，应该给的都是给img添加crossOrigin属性，尝试了一下，确实可用。看下面的一个例子：html代码：12&lt;canvas id=&quot;canvas&quot; style=&quot;display: none&quot;&gt;&lt;/canvas&gt;&lt;img id=&quot;canvasImg&quot; /&gt; javascript代码：1234567891011var img = new Image();img.setAttribute(&apos;crossOrigin&apos;, &apos;anonymous&apos;);var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&apos;2d&apos;);img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height + 200; ctx.drawImage(img, 0, 0); document.getElementById(&apos;canvasImg&apos;).src = canvas.toDataURL(&quot;image/jpeg&quot;, 1); &#125;img.src = &apos;http://img.hb.aicdn.com/38d8f519b3f464a80d85ed9632fed904ed0181f41d632-ZHrigO_fw658&apos;; 这样就可以正常画出图片了。 微信图片的问题但是我发现这个方法用于绘制微信头像的时候有概率会出现问题，当然了这里面指的是将图片的网络地址直接赋值给图片的src。【之所以说有概率会出现问题是因为我通过上面的方法去完成需求的时候并没有画出头像（微信头像放在wx.qlogo.cn域名下，然而我今天准备写这篇文章的时候突然就可以了，见鬼当时的时候我们找了很多方法，发现，在头像url后面加上时间戳的话就可以了【emmm神操作即：1img.src = &apos;http://wx.qlogo.cn/mmopen/vi_32/RnLIHfXibgFHlticiclzflpriaLsC3TS9b2Sbj05Wh3vGlhcFutt18dfkXGUt8x11e4q2KHlX4EHHaBb6XylLQW1kQ/0?timeStamp=&apos;+new Date(); 其他的解法今天找了个新的方法去解决canvas图片跨域的问题：将文件读入到blob文件对象，然后使用URL.createObjectURL转换成src可用的地址123456789101112131415161718192021222324252627282930313233//直接读成blob文件对象function getImageBlob (url, cb) &#123; var xhr = new XMLHttpRequest(); xhr.open('get', url, true); xhr.responseType = 'blob'; xhr.onload = function () &#123; if (this.status == 200) &#123; imgResponse = this.response; //这里面可以直接通过URL的api将其转换，然后赋值给img.src //也可以使用下面的preView方法将其转换成base64之后再赋值 img.src = URL.createObjectURL(this.response); &#125; &#125;; xhr.send(); &#125; //这里面将blob转换成base64 function preView (url) &#123; let reader = new FileReader(); getImageBlob(url, function (blob) &#123; reader.readAsDataURL(blob); &#125;); reader.onload = function (e) &#123; console.log(e.loaded) &#125; &#125; img.onload = function () &#123; canvas.width = img.width; canvas.height = img.height + 200; ctx.drawImage(img, 0, 0); document.getElementById('canvasImg').src = canvas.toDataURL("image/jpeg", 1); &#125; var imgResponse = ''; getImageBlob('http://wx.qlogo.cn/mmopen/vi_32/RnLIHfXibgFHlticiclzflpriaLsC3TS9b2Sbj05Wh3vGlhcFutt18dfkXGUt8x11e4q2KHlX4EHHaBb6XylLQW1kQ/0');]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[测试文章]]></title>
    <url>%2F2019%2F02%2F12%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[hello欢迎来到封闭货车]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
